<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Utility</name>
    </assembly>
    <members>
        <member name="M:Utility.Collections.Generic.CollectionExtensions.CopyTo``1(System.Collections.Generic.ICollection{``0},``0[])">
            <summary>
            Copies the items of the collection to an <typeparamref name="T"/> array starting placing the items in the destination array at the specified index.
            </summary>
            <typeparam name="T">The type of the collection's items</typeparam>
            <param name="collection">The collection</param>
            <param name="destArray">The array which the items will be copied to</param>
            <exception cref="T:System.ArgumentNullException">Either collection or destArray are null</exception>
        </member>
        <member name="M:Utility.Collections.Generic.CollectionExtensions.Swap``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32)">
            <summary>
            Swaps the items in the specified indexes.
            </summary>
            <typeparam name="T">The type of the list of items</typeparam>
            <param name="items">The list of items</param>
            <param name="index1">The index of the first item</param>
            <param name="index2">The index of the second item</param>
            <exception cref="T:System.ArgumentNullException">items is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index was outside the bounds of the collection.</exception>
            <exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IList`1"/> is read-only</exception>
        </member>
        <member name="T:Utility.Disposable">
            <summary>
            Provides a base class for implementing the <see cref="T:System.IDisposable"/> interface.
            </summary>
        </member>
        <member name="M:Utility.Disposable.Dispose">
            <summary>
            Releases any unmanaged resources controlled by this object.
            </summary>
        </member>
        <member name="P:Utility.Disposable.Disposed">
            <summary>
            Get a value indicating whether this object has been disposed of.
            </summary>
        </member>
        <member name="M:Utility.Disposable.Dispose(System.Boolean)">
            <summary>
            Releases any unmanaged resources controlled by this object.
            </summary>
            <param name="disposing">Indicates whether the call came from the finalizer or the dispose method</param>
        </member>
        <member name="T:Utility.EventArgs`1">
            <summary>
            Event args which contain data
            </summary>
            <typeparam name="T">The type of the data object to be stored</typeparam>
        </member>
        <member name="M:Utility.EventArgs`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Utility.EventArgs`1"/> class
            </summary>
            <param name="data">The data of the event args</param>
        </member>
        <member name="P:Utility.EventArgs`1.Data">
            <summary>
            Gets the data object associated with this event args.
            </summary>
        </member>
        <member name="T:Utility.EventHandler`2">
            <summary>
            Represents the method that will handle an event when the event provides data.
            </summary>
            <typeparam name="TSender">The type of the source object</typeparam>
            <typeparam name="TEventArgs">The type of the event data generated by the event</typeparam>
            <param name="sender">The source of the event</param>
            <param name="e">An object that contains the event data</param>
        </member>
        <member name="T:Utility.Interop.ComReleaser`1">
            <summary>
            Automates the disposal of a referenced COM object.
            When the <see cref="T:Utility.Interop.ComReleaser`1"/> instance is disposing, it fires an event in which the developer should close the connection of the COM object to any unmanaged resources,
            and then, this <see cref="T:Utility.Interop.ComReleaser`1"/> instance releases all references to the COM object by calling <see cref="M:System.Runtime.InteropServices.Marshal.FinalReleaseComObject(System.Object)"/> on the COM object.
            </summary>
            <typeparam name="T">The type of the COM object</typeparam>
        </member>
        <member name="M:Utility.Interop.ComReleaser`1.#ctor(`0,Utility.EventHandler{Utility.Interop.ComReleaser{`0},Utility.Interop.ComReleasingEventArgs{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:Utility.Interop.ComReleaser`1"/> class, wrapping the specified COM object and automatically disposing of it.
            Potentially specifying events to be fired when this instance is disposing and after it has been disposed.
            </summary>
            <param name="comObj">The COM object</param>
            <param name="beforeReleasing">The cleanup action to perform before completely releasing the COM object</param>
            <exception cref="T:System.ArgumentNullException">comObj is null.</exception>
            <exception cref="T:System.ArgumentException">The specified object is not a COM object</exception>
        </member>
        <member name="P:Utility.Interop.ComReleaser`1.ComObject">
            <summary>
            Returns the wrapped COM obejct
            </summary>
        </member>
        <member name="T:Utility.Interop.DisposableCollection">
            <summary>
            Automates the disposal of COM objects in the collection.
            When the <see cref="T:Utility.Interop.DisposableCollection"/> instance is disposing, it pops every COM object in it and calls it's <see cref="M:System.IDisposable.Dispose"/> method in which the COM objects frees any unmanaged resources.
            We use non-generic stack because if we did use a generic stack, the stack would be limited a single type of wrapped COM objects, which in turn, defeats the purpose of it.
            </summary>
        </member>
        <member name="M:Utility.Interop.DisposableCollection.#ctor">
            <summary>
            Initialize a new instance of the <see cref="T:Utility.Interop.DisposableCollection"/> class that is empty and has the default initial capacity.
            </summary>
        </member>
        <member name="M:Utility.Interop.DisposableCollection.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Utility.Interop.DisposableCollection"/> class that is empty and has the specified initial capacity or the default initial capacity, whichever is greater.
            </summary>
            <param name="capacity">The initial number of elements that the <see cref="T:Utility.Interop.DisposableCollection"/> can contain</param>
            <exception cref="T:System.ArgumentOutOfRangeException">capacity is less than zero.</exception>
        </member>
        <member name="M:Utility.Interop.DisposableCollection.#ctor(System.Collections.Generic.IEnumerable{System.IDisposable})">
            <summary>
            Initializes a new instance of the <see cref="T:Utility.Interop.DisposableCollection"/> class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied.
            </summary>
            <param name="disposables">The collection to copy elements from.</param>
            <exception cref="T:System.ArgumentNullException">dcos is null.</exception>
        </member>
        <member name="M:Utility.Interop.DisposableCollection.Add``1(``0,Utility.EventHandler{Utility.Interop.ComReleaser{``0},Utility.Interop.ComReleasingEventArgs{``0}})">
            <summary>
            Push a new <see cref="T:Utility.Interop.ComReleaser`1"/> that wraps the COM object and is resposible for the mechanism of disposing of it's COM object into the stack.
            Potentially specifying events to be fired when this COM object is disposing and after it has been disposed.
            </summary>
            <typeparam name="T">The type of the COM object</typeparam>
            <param name="comObject">The COM object</param>
            <param name="beforeReleasing">The cleanup action to perform before completely releasing the COM object</param>
            <returns>For convenience, the COM object</returns>
            <exception cref="T:System.ArgumentNullException">comObj is null.</exception>
            <exception cref="T:System.ArgumentException">The specified object is not a COM object</exception>
        </member>
        <member name="M:Utility.Interop.DisposableCollection.Dispose(System.Boolean)">
            <summary>
            Releases any unmanaged resources controlled by this stack (all of the COM objects).
            </summary>
            <param name="disposing">Indicates whether the call came from the finalizer or the dispose method</param>
            <exception cref="T:System.AggregateException">
            One or more errors occurred in the disposal of one or more of the collection's COM objects.
            If disposing is true, this exception will hold all the errors that occured during the disposal of every failed <see cref="M:System.IDisposable.Dispose"/> call on the wrapping object.
            </exception>
        </member>
        <member name="T:Utility.Interop.IComReleaser">
            <summary>
            The sole reason for this interface is that we use a non-generic stack because if we did use a generic stack, the stack would be limited a single type of wrapped COM objects, which in turn, defeats the purpose of it.
            </summary>
        </member>
        <member name="T:Utility.Interop.IComReleaser`1">
            <summary>
            This interface exists for clarification.
            </summary>
            <typeparam name="T">The type of the COM object</typeparam>
        </member>
        <member name="F:Utility.Interop.Native.NativeMethods.MAX_PATH">
            <summary>
            Even though this is defined as 260, the last character is a '\0' since paths are null-terminated strings.
            Therefore, the actual maximimum is 259.
            However, if you need to allocate a buffer and pass it to unmanaged code to fill the buffer,
            you should check whether or not it expects the buffer to be null-terminated or not.
            Usually the Win32 API does, therefore you should use 260 when calling Win32 API.
            </summary>
        </member>
        <member name="T:Utility.Interop.Native.Types.COAUTHIDENTITY">
            <summary>
            This struct uses Unicode encoding for it's strings,
            therefore the <see cref="F:Utility.Interop.Native.Types.COAUTHIDENTITY.Flags"/> field should always be set to <see cref="F:Utility.Interop.Native.Types.SEC_WINNT_AUTH_IDENTITY.UNICODE"/>.
            
            If you want to pass strings with ANSI encoding, define your own struct similar to this one
            that has <see cref="F:System.Runtime.InteropServices.CharSet.Ansi"/> set in it's <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute"/>.
            In this case, always set the <see cref="F:Utility.Interop.Native.Types.COAUTHIDENTITY.Flags"/> field to <see cref="F:Utility.Interop.Native.Types.SEC_WINNT_AUTH_IDENTITY.ANSI"/>
            </summary>
        </member>
        <member name="F:Utility.Interop.Native.Types.COAUTHIDENTITY.Password">
            <summary>
            Since this is a password, a pointer to <see cref="T:System.Char"/> (char*) shouldn't be used.
            Instead, allocate an <see cref="T:System.IntPtr"/> to an <see cref="T:System.Security.SecureString"/> instance containing the password and pass it here.
            You can use <see cref="M:System.Runtime.InteropServices.Marshal.SecureStringToCoTaskMemUnicode(System.Security.SecureString)"/> to achieve this
            (and than free it using <see cref="M:System.Runtime.InteropServices.Marshal.ZeroFreeCoTaskMemUnicode(System.IntPtr)"/>).
            </summary>
        </member>
        <member name="F:Utility.Interop.Native.Types.COAUTHINFO.pAuthIdentityData">
            <summary>
            A <see cref="T:Utility.Interop.Native.Types.COAUTHIDENTITY"/> struct pointer, see <see cref="T:Utility.Interop.Native.Types.COAUTHIDENTITY"/> documentation for more details.
            </summary>
        </member>
        <member name="F:Utility.Interop.Native.Types.PROPVARIANT.vt">
            <summary />
        </member>
        <member name="T:Utility.Interop.UnmanagedDefinitionAttribute">
            <summary>
            Indicates the original definition of the parameter as specified in a P/Invoke or COM interface method (the unmanaged definition).
            If this is used on a return type, this also indicates that the parameter was moved to be the return type in the managed definition instead of the HRESULT.
            
            Can also indicate the original definition of a field in a structure (a 'class' or a 'struct'), a structure, an interface or an enum.
            
            NOTE: This has no effect whatsoever on behaviors, marshaling or anything at all.
            </summary>
        </member>
        <member name="P:Utility.Interop.UnmanagedDefinitionAttribute.Attributes">
            <summary>
            Specifies any additional attributes applied in original definition
            </summary>
        </member>
        <member name="P:Utility.Interop.UnmanagedDefinitionAttribute.IsParameter">
            <summary>
            When specified on return types,
            indicates whether it is defined as the last parameter in the method or
            it is defined as the actual return type of the method.
            
            true to indicate it is defined as a parameter, otherwise false.
            </summary>
        </member>
        <member name="M:Utility.IO.FileSystem.EnsureExtendedPrefix(System.String)">
            <summary>
            Adds the extended path prefix (\\?\) if not relative or already a device path.
            </summary>
        </member>
        <member name="M:Utility.IO.FileSystem.IsDevice(System.String)">
            <summary>
            Returns true if the path uses any of the DOS device path syntaxes. ("\\.\", "\\?\", or "\??\")
            </summary>
        </member>
        <member name="M:Utility.Linq.EnumerableExtensions.ContainsAll``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns a value indicating whether the second enumerable is entirely contained in the first enumerable, potentially passing an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to be used to determine whether two items are considered equal.
            </summary>
            <typeparam name="TSource">The type of the elements in the enumerables</typeparam>
            <param name="first">The first enumerable</param>
            <param name="second">The second enumerable</param>
            <param name="comparer">If specified, a comparer to be used to determine whether two items are considered equal</param>
            <returns>A value indicating whether the second enumerable is entirely contained in the first enumerable</returns>
            <exception cref="T:System.ArgumentNullException">first or second are null</exception>
        </member>
        <member name="M:Utility.Linq.EnumerableExtensions.ContainsAny``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns a value indicating whether an element from the second enumerable is contained in the first enumerable,
            potentially passing an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to be used to determine whether two items are considered equal.
            </summary>
            <typeparam name="TSource">The type of the elements of the enumerables</typeparam>
            <param name="first">The first enumerable</param>
            <param name="second">The second enumerable</param>
            <param name="comparer">If specified, a comparer to be used to determine whether two items are considered equal</param>
            <returns>A value indicating whether an element from the second enumerable is contained in the first enumerable</returns>
            <exception cref="T:System.ArgumentNullException">first or second are null</exception>
        </member>
        <member name="M:Utility.Linq.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Executes an action on each elements of the enumerable.
            </summary>
            <typeparam name="TSource">The type of the elements of the enumerable</typeparam>
            <param name="source">The enumerable</param>
            <param name="action">The action to be invoked on an element</param>
            <exception cref="T:System.ArgumentNullException">source or action are null</exception>
        </member>
        <member name="M:Utility.Linq.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            Executes an action on each elements of the enumerable.
            </summary>
            <typeparam name="TSource">The type of the elements of the enumerable</typeparam>
            <param name="source">The enumerable</param>
            <param name="action">The action to be invoked on an element. The first parameter of the function is it's index in the enumerable.</param>
            <exception cref="T:System.ArgumentNullException">source or action are null</exception>
        </member>
        <member name="M:Utility.Linq.EnumerableExtensions.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns a value indicating whether the two sequence of elements are equal by comparing their elements,
            potentially passing an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to be used to determine whether two items are considered equal.
            </summary>
            <typeparam name="TSource">The type of the elements of the enumerables</typeparam>
            <param name="first">The first enumerable</param>
            <param name="second">The second enumerable</param>
            <param name="comparer">If specified, a comparer to be used to determine whether two items are considered equal</param>
            <returns>A value indicating whether an element from the second enumerable is contained in the first enumerable</returns>
            <exception cref="T:System.ArgumentNullException">first or second are null</exception>
        </member>
        <member name="M:Utility.Linq.EnumerableExtensions.GetCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the amount of items in an enumerable.
            This method tries to check if the enumerable is an <see cref="T:System.Collections.Generic.ICollection`1"/> or <see cref="T:System.Collections.ICollection"/>,
            if it is one of them, it returns the value of <see cref="P:System.Collections.Generic.ICollection`1.Count"/> or <see cref="P:System.Collections.ICollection.Count"/> respectively.
            If it is no more than just an <see cref="T:System.Collections.Generic.IEnumerable`1"/>, then the method calls <see cref="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0})"/>
            </summary>
            <typeparam name="TSource">The type of the elements in the enumerables</typeparam>
            <param name="source">The enumerable</param>
            <returns>Yhe amount of items in the enumerable (smartly)</returns>
        </member>
        <member name="M:Utility.Linq.EnumerableExtensions.CompareICollectionCount``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Compares the count of each enumerable by trying to cast them into <see cref="T:System.Collections.Generic.ICollection`1"/> and compare the <see cref="P:System.Collections.Generic.ICollection`1.Count"/> property.
            </summary>
            <typeparam name="TFirst">The type of the elements of the first enumerables</typeparam>
            <typeparam name="TSecond">The type of the elements of the second enumerables</typeparam>
            <param name="first">The first enumerable</param>
            <param name="second">The second enumerable</param>
            <returns>True if the method successfully casted both enumerables to <see cref="T:System.Collections.Generic.ICollection`1"/> and their <see cref="P:System.Collections.Generic.ICollection`1.Count"/> properties are equals, otherwise false.</returns>
        </member>
        <member name="T:Utility.PossibleTypesAttribute">
            <summary>
            Indicates the possibles types that this member can take.
            For example, it can be used when a target that takes an '<see cref="T:System.Object"/>' or an '<see cref="T:System.IntPtr"/>'
            that can represent multiple types, interfaces or structures.
            
            NOTE: This has no effect whatsoever on behaviors, marshaling or anything at all.
            </summary>
        </member>
        <member name="T:Utility.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.Argument_CollectionsItemsCountMismatch">
            <summary>
              Looks up a localized string similar to Collections items count mismatch, the collections must have the same amount of items..
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.Argument_InvalidIntegerObj">
            <summary>
              Looks up a localized string similar to The specified object is not of an integer type..
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.Argument_InvalidIntegerType">
            <summary>
              Looks up a localized string similar to The specified argument type is not an integer type..
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.Argument_InvalidIntegerTypeCode">
            <summary>
              Looks up a localized string similar to The specified argument type is not an integer type code..
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.Argument_InvalidNumericObj">
            <summary>
              Looks up a localized string similar to The specified object is not of a numeric type..
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.Argument_InvalidNumericType">
            <summary>
              Looks up a localized string similar to The specified argument type is not a numeric type..
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.Argument_InvalidNumericTypeCode">
            <summary>
              Looks up a localized string similar to The specified argument type is not a numeric type code..
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.Argument_InvalidSplitSize">
            <summary>
              Looks up a localized string similar to Split size must be greater than 1..
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.Argument_InvalidValueType">
            <summary>
              Looks up a localized string similar to The type of the value is invalid..
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.Argument_NullOrEmpty">
            <summary>
              Looks up a localized string similar to Value cannot null or empty..
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.Argument_OutOfRange_ArgIndex">
            <summary>
              Looks up a localized string similar to The argument index must be a non-negative number..
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.Argument_OutOfRange_Count">
            <summary>
              Looks up a localized string similar to Count must be non-negative and start index and count were out of bounds of the collection..
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.Argument_OutOfRange_Index">
            <summary>
              Looks up a localized string similar to Index was outside the bounds of the collection. It must be non-negative and less than the size of the collection..
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.Argument_OutOfRange_LengthTooShort">
            <summary>
              Looks up a localized string similar to The length of the destination is too short. It must be equal or greater to the collection items count..
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.Argument_StreamPositionOutOfBounds">
            <summary>
              Looks up a localized string similar to The current position of the stream and count were out of bounds for the stream or count is greater than the number of bytes from the current position of the stream to the end of the stream..
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.Argument_StringNullOrWhiteSpace">
            <summary>
              Looks up a localized string similar to String cannot null or whitespace..
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.DisposableCollection_DisposingError">
            <summary>
              Looks up a localized string similar to One or more errors occurred in the disposal of one or more of the collection&apos;s object..
            </summary>
        </member>
        <member name="P:Utility.Properties.Resources.InvalidOperation_EnumNoDefinedValues">
            <summary>
              Looks up a localized string similar to The enum has no values defined..
            </summary>
        </member>
    </members>
</doc>
